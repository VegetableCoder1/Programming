/*
260 只出现一次的数字III
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 
找出只出现一次的那两个元素
时间复杂度O(n) 空间复杂度O(1)

[思路]
我们要找的这两个数字是不同的，所以它俩至少有一位是不同的，
所以我们可以根据这一位，把数组分成这一位都是 1 的一类和这一位都是 0 的一类，这样就把这两个数分到两组里了。
然后分别对两组求异或即可

[1,2,1,3,2,5]

把上边所有的数字异或，最后得到的结果就是 tmp = 3 ^ 5 = 6 (110) 
异或后结果为1的位就是可以用来划分的位

k = tmp&(-tmp) 可以得出最低位(也就是最右边)为1的bit位(这个操作不太会事先知道)对应的数
0110 & 1010 = 0010 = 010

倒数第二位为 0 的组
1 = 001
1 = 001
5 = 101

倒数第三位为 1 的组    
2 = 010
2 = 010
3 = 011

最后组内数字依次异或即可。
*/

#include <bits/stdc++.h>
using namespace std;
vector<int> singleNumber(vector<int> &nums)
{
    int s = 0;
    for (int ss : nums)
    {
        s = s ^ ss;
    }
    int k = s & (-s);
    vector<int> rs(2, 0);
    for (int num : nums)
    {
        if (num & k)
        {
            //第二组
            rs[0] ^= num;
        }
        else
        {
            //第一组
            rs[1] ^= num;
        }
    }
    return rs;
}
